{% extends "skeleton.html" %}

{% block content %}
<div class="section">
  <div class="container">
   <div id="mapContainer" class="row justify-content-center">
       
    
  </div>
 </div>
</div>

<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>
var percentColors = [
    { pct: 0.0, color: { r: 0xff, g: 0x00, b: 0 } },
    { pct: 0.5, color: { r: 0xff, g: 0xff, b: 0 } },
    { pct: 1.0, color: { r: 0x00, g: 0xff, b: 0 } } ];

var getColorForPercentage = function(pct) {
    for (var i = 1; i < percentColors.length - 1; i++) {
        if (pct < percentColors[i].pct) {
            break;
        }
    }
    var lower = percentColors[i - 1];
    var upper = percentColors[i];
    var range = upper.pct - lower.pct;
    var rangePct = (pct - lower.pct) / range;
    var pctLower = 1 - rangePct;
    var pctUpper = rangePct;
    var color = {
        r: Math.floor(lower.color.r * pctLower + upper.color.r * pctUpper),
        g: Math.floor(lower.color.g * pctLower + upper.color.g * pctUpper),
        b: Math.floor(lower.color.b * pctLower + upper.color.b * pctUpper)
    };
    return 'rgb(' + [color.r, color.g, color.b].join(',') + ')';
    // or output as hex if preferred
}  

//Map dimensions (in pixels)
var width = 600,
    height = 385;

//Map projection
var projection = d3.geo.mercator()
    .scale(7199.647436311883)
    .center([8.223981,46.82243520556143]) //projection center
    .translate([width/2,height/2]) //translate to center the map in view

//Generate paths based on projection
var path = d3.geo.path()
    .projection(projection);

//Create an SVG
var svg = d3.select("#mapContainer").append("svg")
    .attr("width", width)
    .attr("height", height);

//Group for the map features
var features = svg.append("g")
    .attr("class","features");

//Create zoom/pan listener
//Change [1,Infinity] to adjust the min/max zoom scale
var zoom = d3.behavior.zoom()
    .scaleExtent([1, Infinity])
    .on("zoom",zoomed);

svg.call(zoom);

d3.json("/static/mcp.json",function(error,geodata) {
  if (error) return console.log(error); //unknown error, check the console

  d3.json("/get_votes",function(error,dbdata) { 
  if (error) return console.log(error); //unknown error, check the console

          for(var n = 0; n < geodata.features.length; n++){

         
            var municip = geodata.features[n].properties.id;
           
            if (typeof dbdata.data[municip] !== 'undefined')
            {
              geodata.features[n].properties.votePercentage = dbdata.data[municip][0]/dbdata.data[municip][1];
            }
           
            else {
              console.log(municip)
            }
              

          
          }
        






  //Create a path for each map feature in the data
  features.selectAll("path")
    .data(geodata.features)
    .enter()
    .append("path")
    .attr("d",path)
    .on("click",clicked)
    .style("fill", function(d){
            //get the data value
            var votePercentage = d.properties.votePercentage;

           return getColorForPercentage(votePercentage);

          });

  });
});

// Add optional onClick events for features here
// d.properties contains the attributes (e.g. d.properties.name, d.properties.population)
function clicked(d,i) {

}


//Update map on zoom/pan
function zoomed() {
  features.attr("transform", "translate(" + zoom.translate() + ")scale(" + zoom.scale() + ")")
      .selectAll("path").style("stroke-width", 1 / zoom.scale() + "px" );
}

</script>








<script type="text/javascript" charset="utf-8">
$(document).ready(function(){

var percentColors = [
    { pct: 0.0, color: { r: 0xff, g: 0x00, b: 0 } },
    { pct: 0.5, color: { r: 0xff, g: 0xff, b: 0 } },
    { pct: 1.0, color: { r: 0x00, g: 0xff, b: 0 } } ];

var getColorForPercentage = function(pct) {
    for (var i = 1; i < percentColors.length - 1; i++) {
        if (pct < percentColors[i].pct) {
            break;
        }
    }
    var lower = percentColors[i - 1];
    var upper = percentColors[i];
    var range = upper.pct - lower.pct;
    var rangePct = (pct - lower.pct) / range;
    var pctLower = 1 - rangePct;
    var pctUpper = rangePct;
    var color = {
        r: Math.floor(lower.color.r * pctLower + upper.color.r * pctUpper),
        g: Math.floor(lower.color.g * pctLower + upper.color.g * pctUpper),
        b: Math.floor(lower.color.b * pctLower + upper.color.b * pctUpper)
    };
    return 'rgb(' + [color.r, color.g, color.b].join(',') + ')';
    // or output as hex if preferred
}  
  $.ajax({
    type: "get",
    url: "get_votes",
    success:function(data)
    {
      //console.log the response
      console.log(data);
      $.each(data.data, function( index, row ) {
        $('.thenmap').find('path[thenmap\\:shapeid='+row[0]+']').css({ fill: getColorForPercentage(row[1]/row[2]) });

     
});
     
    },
    error:function(err) 
    {
        console.log(err)
    }
  });

});
</script>

{% endblock %}
