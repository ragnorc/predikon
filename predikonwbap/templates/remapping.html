{% extends "skeleton.html" %}

{% block content %}

<div class="section">
    <div class="container">
        <h2>Remapping Switzerland with t-SNE</h2>
        <p>Below, each municipality is represented by a dot in the plot on the right-hand side. On the left, the
            geographical map of Switzerland depicts the municipalities with a colour that is chosen based on the
            position in the plot.</p>
        <div style="padding-top: 50px; padding-bottom: 50px;">
            <div id="mapContainer" style="float:left; margin-right:20px" class="row justify-content-center"></div>
            <div id="tsneContainer" class="row justify-content-center"></div>
        </div>
        <h3>Explanation</h3>
        <p> On the right part above, each municipality is shown by a dot. This representation is obtained directly from
            all the results to national-level issue votes, using a dimensionality reduction technique called t-SNE (for
            t-distributed stochastic neighbor embedding).</p>

        <p> In contrast to principal component analysis as used in the voting patterns, t-SNE enables to capture
            non-linear relationships present in the voting data. Informally, it captures the relative similarity between
            municipalities in the data and it tries to keep these similarities in a two-dimensional space. Hence, it is
            potentially able to reveal more insights in two dimensions and generate the visualization above. However, it
            lacks the easy interpretability of individual axes.</p>

        <p> In line with the principal component analysis, we observe a clustering in voting behavior by the language
            spoken in each municipality. However, even more remarkable, a finer sub-clustering by canton is also
            obtained. For example, spot the cluster corresponding to the canton of Bern: the German-speaking
            municipalities are located on right hand side of the plot and the French-speaking municipalities are located
            on the left hand side of the plot. First, municipalities of Bern are split by the language spoken and then
            grouped together within their cantonal sub-cluster. As also apparent in the principal component analysis,
            the canton of Wallis exhibits a unique voting behavior. It is isolated at the top of the plot, but it is
            still split according to the two spoken languages.</p>

        <p>The drop-down menu allows you to choose the data used to color the dots that represent the municipalities.
            The most interesting data to look at are the canton a municipality belongs to. To reduce the number of
            elements in the legend, it is possible to choose only cantons that speak a specific language.</p>

        <p> On the left hand side above, the color of each municipality is directly determined by its position in the
            two-dimensional space on the right side.</p>
    </div>
</div>

<script>
    width = 400
    height = 400

    var svg = d3.select("#tsneContainer").append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g")


    //Map dimensions (in pixels)
    var mapWidth = 600,
        mapHeight = 385;

    //Map projection
    var projection = d3.geoMercator()
        .scale(7199.647436311883)
        .center([8.223981, 46.82243520556143]) //projection center
        .translate([mapWidth / 2, mapHeight / 2]) //translate to center the map in view

    //Generate paths based on projection
    var path2 = d3.geoPath()
        .projection(projection);



    var svg2 = d3.select("#mapContainer").append("svg")
        .attr("width", mapWidth)
        .attr("height", mapHeight);

    //Group for the map features
    var features2 = svg2.append("g")
        .attr("class", "features");

    //Create zoom/pan listener
    //Change [1,Infinity] to adjust the min/max zoom scale
    var zoom2 = d3.zoom()
        .scaleExtent([1, Infinity])
        .on("zoom", zoomed);

    svg2.call(zoom2);

    d3.json("/static/swiss-mcp.json", function (error, geodata) {
        if (error) return console.log(error); //unknown error, check the console

        var mcpDict = JSON.parse('{{ mcpDict | tojson | safe}}');
        var minValue = [100, 100];
        var maxValue = [-100, -100];

        for (var n = 0; n < geodata.features.length; n++) {
            var municip = geodata.features[n].properties.shapeid;
            geodata.features[n].properties.id = municip;

            if (typeof mcpDict[municip] !== 'undefined') {
                geodata.features[n].properties.votePercentage = mcpDict[municip]
                    .numYes / mcpDict[municip]
                    .numTotal;
                geodata.features[n].properties.pop = mcpDict[municip].pop;
                geodata.features[n].properties.area = mcpDict[municip].area;
                geodata.features[n].properties.name = mcpDict[municip].name;
                geodata.features[n].properties.flag = mcpDict[municip].flag;
                geodata.features[n].properties.pc = mcpDict[municip].postal_code;
                geodata.features[n].properties.language = mcpDict[municip].language;
                geodata.features[n].properties.tsne_1 = mcpDict[municip].tsne_1;
                geodata.features[n].properties.tsne_2 = mcpDict[municip].tsne_2;


                if (mcpDict[municip].tsne_1 <= minValue[0]) minValue[0] = mcpDict[municip].tsne_1;
                if (mcpDict[municip].tsne_1 >= maxValue[0]) maxValue[0] = mcpDict[municip].tsne_1;
                if (mcpDict[municip].tsne_1 <= minValue[1]) minValue[1] = mcpDict[municip].tsne_2;
                if (mcpDict[municip].tsne_1 >= maxValue[1]) maxValue[1] = mcpDict[municip].tsne_2;

            }
        }
        var scale1 = d3.scaleLinear()
            .range(["#009FFF", "#ec2F4B"])
            .domain([minValue[0], maxValue[0]]);
        var scale2 = d3.scaleLinear()
            .range(["#38ef7d", "#ec2F4B"])
            .domain([minValue[1], maxValue[1]]);

        // Add X axis
        var x = d3.scaleLinear()
            .domain([70, -70])
            .range([0, width])

        // Add Y axis
        var y = d3.scaleLinear()
            .domain([70, -70])
            .range([0, height]);
        svg.append("g")
            .attr("transform", "translate(0," + y(0) + ")")
            .call(d3.axisBottom(x).tickSize(0))
            .selectAll("text").remove()


        svg.append("g")
            .attr("transform", "translate(" + x(0) + ",0)")
            .call(d3.axisLeft(y).tickSize(0))
            .selectAll("text").remove();


        // Add dots
        svg.append('g')
            .selectAll("dot")
            .data(geodata.features)
            .enter()
            .append("circle")
            .attr("mcpId", function (d) {
                return d.properties.id
            })

            .attr("cx", function (d) {

                return x(d.properties.tsne_1 || 0);
            })
            .attr("cy", function (d) {
                return y(d.properties.tsne_2 || 0);
            })
            .attr("r", function (d) {
                return (d.properties.tsne_1 == null || d.properties.tsne_2 == null) ? 0 : 2;
            })
            .style("fill", "#69b3a2")
            .on("mouseover", mouseOverEvent)
            .on("mouseout", mouseOutEvent)

        //Create a path for each map feature in the data
        features2.selectAll("path")
            .data(geodata.features)
            .enter()
            .append("path")
            .attr("d", path2)
            .attr("mcpId", function (d) {
                return Math.round(d.properties.id);
            })
            .style("stroke", "black")
            .style("stroke-width", '0.25px')
            .style("fill", function (d) {
                return d3.scaleLinear()
                    .range([scale1(d.properties.tsne_1), scale2(d.properties.tsne_2)])(0.5)
            })
            .on("mouseover", mouseOverEvent)
            .on("mouseout", mouseOutEvent)


    });

    function mouseOverEvent(d) {
        $("path").popover('hide');
        $("#mapContainer").find("[mcpId='" + d.properties.id + "']").css(
            "opacity", "0.3").eq(0).popover({
            trigger: 'focus',
            title: d.properties.name,
            html: true,
            content: '<p id="mcp"></p></div> Area: ' +
                d.properties.area + ' km<sup>2</sup> <br/> Population: ' +
                d.properties.pop + ' <br/> Language: ' +
                d.properties.language + ' <br/> Postal Code: ' +
                d.properties.pc,
            container: 'body',
            placement: 'top',
            template: '<div class="popover" role="tooltip"><div class="arrow"></div><img src="' +
                d
                .properties.flag +
                '" style="width:30px;height:30px; float: left; margin: 10px" id="flag"></img><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
        }).popover("show");
        $("#tsneContainer").find("[mcpId='" + d.properties.id + "']").css("stroke", "black")
            .css("stroke-width", '2px');
    }

    function mouseOutEvent(d) {
        $("[mcpId='" + d.properties.id + "']")
            .popover("hide").css("opacity", "1")
        $("#tsneContainer").find("[mcpId='" + d.properties.id + "']").css("stroke", "black")
            .css("stroke-width", '0px');

    };

    //Update map on zoom/pan
    function zoomed() {
        features.attr("transform", "translate(" + zoom2.translate() + ")scale(" + zoom2.scale() + ")")
            .selectAll("path").style("stroke-width", 1 / zoom2.scale() + "px");
    }
</script>



{% endblock %}