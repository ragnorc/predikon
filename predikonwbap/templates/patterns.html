{% extends "skeleton.html" %}

{% block content %}

<div class="section">
    <div class="container">
        <h2>Voting Patterns</h2>
        <p>On the map below, each municipality is shown with a color that represents its voting habits, from 1981 until
            today. Two municipalities with similar colors have similar voting habits.
            Observe for instance the differences between urban centers and rural areas, or between the different
            linguistic regions.</p>
        <div id="mapContainer" style="float:left; width:50%" class="row justify-content-center"></div>
        <div id="svdContainer" style="width:50%" class="row justify-content-center"></div>
        <h3>Explanation</h3>
        <p>On the right part above, each municipality is shown by a dot. This representation is obtained directly
            from all the results to national-level issue votes, using a dimensionality reduction technique. Overall,
            two municipalities are close to each other in this space if they vote similarly. The axes capture the
            topics and trends that most divided the municipalities during past votes. The first axis (horizontal)
            mainly represents themes associated to the openness of Switzerland, as well as social insurances. The
            second axis (vertical) mainly represents themes associated to transports, environment and agriculture.
            Below, we provide interpretations of these axes in terms of the most important votes that they
            represent.</p>

        <p> The drop-down menu allows you to choose the data used to color the dots that represent the
            municipalities. For example, one can observe that there is a strong link between the population density
            and the voting habits.</p>

        <p> On the left side above, the color of each municipality is directly determined by its position in the
            two-dimensional space on the right side. You can find out more information about our data and procedures
            in this article.</p>


    </div>
</div>
<script>
</script>
<script>
    var margin = {
            top: 10,
            right: 30,
            bottom: 30,
            left: 60
        },
        width = 460 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;

    var svg = d3.select("#svdContainer").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")")

    //Map dimensions (in pixels)
    var mapWidth = 600,
        mapHeight = 385;

    //Map projection
    var projection = d3.geoMercator()
        .scale(7199.647436311883)
        .center([8.223981, 46.82243520556143]) //projection center
        .translate([mapWidth / 2, mapHeight / 2]) //translate to center the map in view

    //Generate paths based on projection
    var path2 = d3.geoPath()
        .projection(projection);



    var svg2 = d3.select("#mapContainer").append("svg")
        .attr("width", mapWidth)
        .attr("height", mapHeight);

    //Group for the map features
    var features2 = svg2.append("g")
        .attr("class", "features");

    //Create zoom/pan listener
    //Change [1,Infinity] to adjust the min/max zoom scale
    var zoom2 = d3.zoom()
        .scaleExtent([1, Infinity])
        .on("zoom", zoomed);

    svg2.call(zoom2);

    d3.json("/static/swiss-mcp.json", function (error, geodata) {
        if (error) return console.log(error); //unknown error, check the console

        var mcpDict = JSON.parse('{{ mcpDict | tojson | safe}}');
        var minSVD = [100, 100];
        var maxSVD = [-100, -100];

        for (var n = 0; n < geodata.features.length; n++) {
            var municip = geodata.features[n].properties.shapeid;
            geodata.features[n].properties.id = municip;

            if (typeof mcpDict[municip] !== 'undefined') {
                geodata.features[n].properties.votePercentage = mcpDict[municip]
                    .numYes / mcpDict[municip]
                    .numTotal;
                geodata.features[n].properties.pop = mcpDict[municip].pop;
                geodata.features[n].properties.area = mcpDict[municip].area;
                geodata.features[n].properties.name = mcpDict[municip].name;
                geodata.features[n].properties.flag = mcpDict[municip].flag;
                geodata.features[n].properties.pc = mcpDict[municip].postal_code;
                geodata.features[n].properties.language = mcpDict[municip].language;
                geodata.features[n].properties.svd_1 = mcpDict[municip].svd_1;
                geodata.features[n].properties.svd_2 = mcpDict[municip].svd_2;


                if (mcpDict[municip].svd_1 <= minSVD[0]) minSVD[0] = mcpDict[municip].svd_1;
                if (mcpDict[municip].svd_1 >= maxSVD[0]) maxSVD[0] = mcpDict[municip].svd_1;
                if (mcpDict[municip].svd_1 <= minSVD[1]) minSVD[1] = mcpDict[municip].svd_2;
                if (mcpDict[municip].svd_1 >= maxSVD[1]) maxSVD[1] = mcpDict[municip].svd_2;

            }
        }
        var scale1 = d3.scaleLinear()
            .range(["#009FFF", "#ec2F4B"])
            .domain([minSVD[0], maxSVD[0]]);
        var scale2 = d3.scaleLinear()
            .range(["#38ef7d", "#ec2F4B"])
            .domain([minSVD[1], maxSVD[1]]);








        // Add X axis
        var x = d3.scaleLinear()
            .domain([2, -2])
            .range([0, width])

        // Add Y axis
        var y = d3.scaleLinear()
            .domain([-2.5, 2.5])
            .range([0, height]);
        svg.append("g")
            .attr("transform", "translate(0," + y(0) + ")")
            .call(d3.axisBottom(x).tickSize(0))
            .selectAll("text").remove()


        svg.append("g")
            .attr("transform", "translate(" + x(0) + ",0)")
            .call(d3.axisLeft(y).tickSize(0))
            .selectAll("text").remove();


        // Add dots
        svg.append('g')
            .selectAll("dot")
            .data(geodata.features)
            .enter()
            .append("circle")
            .attr("mcpId", function (d) {
                return d.properties.id
            })

            .attr("cx", function (d) {

                return x(d.properties.svd_1 || 0);
            })
            .attr("cy", function (d) {
                return y(d.properties.svd_2 || 0);
            })
            .attr("r", function (d) {
                return (d.properties.svd_1 == null || d.properties.svd_2 == null) ? 0 : 2;
            })
            .style("fill", "#69b3a2")
            .on("mouseover", mouseOverEvent)
            .on("mouseout", mouseOutEvent)

        //Create a path for each map feature in the data
        features2.selectAll("path")
            .data(geodata.features)
            .enter()
            .append("path")
            .attr("d", path2)
            .attr("mcpId", function (d) {
                return Math.round(d.properties.id);
            })
            .style("stroke", "black")
            .style("stroke-width", '0.25px')
            .style("fill", function (d) {
                return d3.scaleLinear()
                    .range([scale1(d.properties.svd_1), scale2(d.properties.svd_2)])(0.5)
            })
            .on("mouseover", mouseOverEvent)
            .on("mouseout", mouseOutEvent)


    });

    function mouseOverEvent(d) {
        $("path").popover('hide');
        $("#mapContainer").find("[mcpId='" + d.properties.id + "']").css(
            "opacity", "0.3").eq(0).popover({
            trigger: 'focus',
            title: d.properties.name,
            html: true,
            content: '<p id="mcp"></p></div> Area: ' +
                d.properties.area + ' km<sup>2</sup> <br/> Population: ' +
                d.properties.pop + ' <br/> Language: ' +
                d.properties.language + ' <br/> Postal Code: ' +
                d.properties.pc,
            container: 'body',
            placement: 'top',
            template: '<div class="popover" role="tooltip"><div class="arrow"></div><img src="' +
                d
                .properties.flag +
                '" style="width:30px;height:30px; float: left; margin: 10px" id="flag"></img><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
        }).popover("show");
        $("#svdContainer").find("[mcpId='" + d.properties.id + "']").css("stroke", "black")
            .css("stroke-width", '2px');
    }

    function mouseOutEvent(d) {
        $("[mcpId='" + d.properties.id + "']")
            .popover("hide").css("opacity", "1")
        $("#svdContainer").find("[mcpId='" + d.properties.id + "']").css("stroke", "black")
            .css("stroke-width", '0px');

    };

    //Update map on zoom/pan
    function zoomed() {
        features.attr("transform", "translate(" + zoom2.translate() + ")scale(" + zoom2.scale() + ")")
            .selectAll("path").style("stroke-width", 1 / zoom2.scale() + "px");
    }
</script>


{% endblock %}